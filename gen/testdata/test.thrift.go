// Code generated by thriftrw

package testdata

import (
	"fmt"
	"github.com/thriftrw/thriftrw-go/wire"
	"strings"
)

type _List_ArbitraryValue_ValueList []*ArbitraryValue

func (v _List_ArbitraryValue_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_ArbitraryValue_ValueList) Close() {
}

type _Map_String_ArbitraryValue_MapItemList map[string]*ArbitraryValue

func (m _Map_String_ArbitraryValue_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueString(k), Value: v.ToWire()})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_String_ArbitraryValue_MapItemList) Close() {
}
func _ArbitraryValue_Read(w wire.Value) (*ArbitraryValue, error) {
	var v ArbitraryValue
	err := v.FromWire(w)
	return &v, err
}
func _List_ArbitraryValue_Read(l wire.List) ([]*ArbitraryValue, error) {
	if l.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]*ArbitraryValue, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := _ArbitraryValue_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _Map_String_ArbitraryValue_Read(m wire.Map) (map[string]*ArbitraryValue, error) {
	if m.KeyType != wire.TBinary {
		return nil, nil
	}
	if m.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*ArbitraryValue, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _ArbitraryValue_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}

type ArbitraryValue struct {
	BoolValue   *bool
	Int64Value  *int64
	ListValue   []*ArbitraryValue
	MapValue    map[string]*ArbitraryValue
	StringValue *string
}

func (v *ArbitraryValue) ToWire() wire.Value {
	var fs [5]wire.Field
	i := 0
	if v.BoolValue != nil {
		fs[i] = wire.Field{ID: 1, Value: wire.NewValueBool(*(v.BoolValue))}
		i++
	}
	if v.Int64Value != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueI64(*(v.Int64Value))}
		i++
	}
	if v.ListValue != nil {
		fs[i] = wire.Field{ID: 4, Value: wire.NewValueList(wire.List{ValueType: wire.TStruct, Size: len(v.ListValue), Items: _List_ArbitraryValue_ValueList(v.ListValue)})}
		i++
	}
	if v.MapValue != nil {
		fs[i] = wire.Field{ID: 5, Value: wire.NewValueMap(wire.Map{KeyType: wire.TBinary, ValueType: wire.TStruct, Size: len(v.MapValue), Items: _Map_String_ArbitraryValue_MapItemList(v.MapValue)})}
		i++
	}
	if v.StringValue != nil {
		fs[i] = wire.Field{ID: 3, Value: wire.NewValueString(*(v.StringValue))}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *ArbitraryValue) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TBool {
				var x bool
				x, err = f.Value.GetBool(), error(nil)
				v.BoolValue = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TI64 {
				var x int64
				x, err = f.Value.GetI64(), error(nil)
				v.Int64Value = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if f.Value.Type() == wire.TList {
				v.ListValue, err = _List_ArbitraryValue_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 5:
			if f.Value.Type() == wire.TMap {
				v.MapValue, err = _Map_String_ArbitraryValue_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TBinary {
				var x string
				x, err = f.Value.GetString(), error(nil)
				v.StringValue = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *ArbitraryValue) String() string {
	var fs [5]string
	i := 0
	if v.BoolValue != nil {
		fs[i] = fmt.Sprintf("BoolValue: %v", *(v.BoolValue))
		i++
	}
	if v.Int64Value != nil {
		fs[i] = fmt.Sprintf("Int64Value: %v", *(v.Int64Value))
		i++
	}
	if v.ListValue != nil {
		fs[i] = fmt.Sprintf("ListValue: %v", v.ListValue)
		i++
	}
	if v.MapValue != nil {
		fs[i] = fmt.Sprintf("MapValue: %v", v.MapValue)
		i++
	}
	if v.StringValue != nil {
		fs[i] = fmt.Sprintf("StringValue: %v", *(v.StringValue))
		i++
	}
	return fmt.Sprintf("ArbitraryValue{%v}", strings.Join(fs[:i], ", "))
}

type ContactInfo struct{ EmailAddress string }

func (v *ContactInfo) ToWire() wire.Value {
	var fs [1]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueString(v.EmailAddress)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *ContactInfo) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TBinary {
				v.EmailAddress, err = f.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *ContactInfo) String() string {
	var fs [1]string
	i := 0
	fs[i] = fmt.Sprintf("EmailAddress: %v", v.EmailAddress)
	i++
	return fmt.Sprintf("ContactInfo{%v}", strings.Join(fs[:i], ", "))
}
func _Pdf_Read(w wire.Value) (Pdf, error) {
	var x Pdf
	err := x.FromWire(w)
	return x, err
}

type Document struct {
	Pdf       Pdf
	PlainText *string
}

func (v *Document) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	if v.Pdf != nil {
		fs[i] = wire.Field{ID: 1, Value: v.Pdf.ToWire()}
		i++
	}
	if v.PlainText != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueString(*(v.PlainText))}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Document) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TBinary {
				v.Pdf, err = _Pdf_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TBinary {
				var x string
				x, err = f.Value.GetString(), error(nil)
				v.PlainText = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Document) String() string {
	var fs [2]string
	i := 0
	if v.Pdf != nil {
		fs[i] = fmt.Sprintf("Pdf: %v", v.Pdf)
		i++
	}
	if v.PlainText != nil {
		fs[i] = fmt.Sprintf("PlainText: %v", *(v.PlainText))
		i++
	}
	return fmt.Sprintf("Document{%v}", strings.Join(fs[:i], ", "))
}

type DoesNotExistException struct{ Key string }

func (v *DoesNotExistException) ToWire() wire.Value {
	var fs [1]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueString(v.Key)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *DoesNotExistException) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TBinary {
				v.Key, err = f.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *DoesNotExistException) String() string {
	var fs [1]string
	i := 0
	fs[i] = fmt.Sprintf("Key: %v", v.Key)
	i++
	return fmt.Sprintf("DoesNotExistException{%v}", strings.Join(fs[:i], ", "))
}
func (v *DoesNotExistException) Error() string {
	return v.String()
}
func _Point_Read(w wire.Value) (*Point, error) {
	var v Point
	err := v.FromWire(w)
	return &v, err
}

type Edge struct {
	End   *Point
	Start *Point
}

func (v *Edge) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 2, Value: v.End.ToWire()}
	i++
	fs[i] = wire.Field{ID: 1, Value: v.Start.ToWire()}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Edge) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 2:
			if f.Value.Type() == wire.TStruct {
				v.End, err = _Point_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TStruct {
				v.Start, err = _Point_Read(f.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Edge) String() string {
	var fs [2]string
	i := 0
	fs[i] = fmt.Sprintf("End: %v", v.End)
	i++
	fs[i] = fmt.Sprintf("Start: %v", v.Start)
	i++
	return fmt.Sprintf("Edge{%v}", strings.Join(fs[:i], ", "))
}

type _List_EnumDefault_ValueList []EnumDefault

func (v _List_EnumDefault_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_EnumDefault_ValueList) Close() {
}

type _Map_EnumWithDuplicateValues_I32_MapItemList map[EnumWithDuplicateValues]int32

func (m _Map_EnumWithDuplicateValues_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: k.ToWire(), Value: wire.NewValueI32(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_EnumWithDuplicateValues_I32_MapItemList) Close() {
}

type _Set_EnumWithValues_ValueList map[EnumWithValues]struct{}

func (v _Set_EnumWithValues_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_EnumWithValues_ValueList) Close() {
}
func _EnumDefault_Read(w wire.Value) (EnumDefault, error) {
	var v EnumDefault
	err := v.FromWire(w)
	return v, err
}
func _List_EnumDefault_Read(l wire.List) ([]EnumDefault, error) {
	if l.ValueType != wire.TI32 {
		return nil, nil
	}
	o := make([]EnumDefault, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := _EnumDefault_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _EnumWithDuplicateValues_Read(w wire.Value) (EnumWithDuplicateValues, error) {
	var v EnumWithDuplicateValues
	err := v.FromWire(w)
	return v, err
}
func _Map_EnumWithDuplicateValues_I32_Read(m wire.Map) (map[EnumWithDuplicateValues]int32, error) {
	if m.KeyType != wire.TI32 {
		return nil, nil
	}
	if m.ValueType != wire.TI32 {
		return nil, nil
	}
	o := make(map[EnumWithDuplicateValues]int32, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := _EnumWithDuplicateValues_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _EnumWithValues_Read(w wire.Value) (EnumWithValues, error) {
	var v EnumWithValues
	err := v.FromWire(w)
	return v, err
}
func _Set_EnumWithValues_Read(s wire.Set) (map[EnumWithValues]struct{}, error) {
	if s.ValueType != wire.TI32 {
		return nil, nil
	}
	o := make(map[EnumWithValues]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		i, err := _EnumWithValues_Read(x)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}

type EnumContainers struct {
	ListOfEnums []EnumDefault
	MapOfEnums  map[EnumWithDuplicateValues]int32
	SetOfEnums  map[EnumWithValues]struct{}
}

func (v *EnumContainers) ToWire() wire.Value {
	var fs [3]wire.Field
	i := 0
	if v.ListOfEnums != nil {
		fs[i] = wire.Field{ID: 1, Value: wire.NewValueList(wire.List{ValueType: wire.TI32, Size: len(v.ListOfEnums), Items: _List_EnumDefault_ValueList(v.ListOfEnums)})}
		i++
	}
	if v.MapOfEnums != nil {
		fs[i] = wire.Field{ID: 3, Value: wire.NewValueMap(wire.Map{KeyType: wire.TI32, ValueType: wire.TI32, Size: len(v.MapOfEnums), Items: _Map_EnumWithDuplicateValues_I32_MapItemList(v.MapOfEnums)})}
		i++
	}
	if v.SetOfEnums != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueSet(wire.Set{ValueType: wire.TI32, Size: len(v.SetOfEnums), Items: _Set_EnumWithValues_ValueList(v.SetOfEnums)})}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *EnumContainers) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TList {
				v.ListOfEnums, err = _List_EnumDefault_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TMap {
				v.MapOfEnums, err = _Map_EnumWithDuplicateValues_I32_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TSet {
				v.SetOfEnums, err = _Set_EnumWithValues_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *EnumContainers) String() string {
	var fs [3]string
	i := 0
	if v.ListOfEnums != nil {
		fs[i] = fmt.Sprintf("ListOfEnums: %v", v.ListOfEnums)
		i++
	}
	if v.MapOfEnums != nil {
		fs[i] = fmt.Sprintf("MapOfEnums: %v", v.MapOfEnums)
		i++
	}
	if v.SetOfEnums != nil {
		fs[i] = fmt.Sprintf("SetOfEnums: %v", v.SetOfEnums)
		i++
	}
	return fmt.Sprintf("EnumContainers{%v}", strings.Join(fs[:i], ", "))
}

type EnumDefault int32

const (
	EnumDefaultFoo EnumDefault = 0
	EnumDefaultBar EnumDefault = 1
	EnumDefaultBaz EnumDefault = 2
)

func (v EnumDefault) ToWire() wire.Value {
	return wire.NewValueI32(int32(v))
}
func (v *EnumDefault) FromWire(w wire.Value) error {
	*v = (EnumDefault)(w.GetI32())
	return nil
}

type EnumWithDuplicateName int32

const (
	EnumWithDuplicateNameA EnumWithDuplicateName = 0
	EnumWithDuplicateNameB EnumWithDuplicateName = 1
	EnumWithDuplicateNameC EnumWithDuplicateName = 2
	EnumWithDuplicateNameP EnumWithDuplicateName = 3
	EnumWithDuplicateNameQ EnumWithDuplicateName = 4
	EnumWithDuplicateNameR EnumWithDuplicateName = 5
	EnumWithDuplicateNameX EnumWithDuplicateName = 6
	EnumWithDuplicateNameY EnumWithDuplicateName = 7
	EnumWithDuplicateNameZ EnumWithDuplicateName = 8
)

func (v EnumWithDuplicateName) ToWire() wire.Value {
	return wire.NewValueI32(int32(v))
}
func (v *EnumWithDuplicateName) FromWire(w wire.Value) error {
	*v = (EnumWithDuplicateName)(w.GetI32())
	return nil
}

type EnumWithDuplicateValues int32

const (
	EnumWithDuplicateValuesP EnumWithDuplicateValues = 0
	EnumWithDuplicateValuesQ EnumWithDuplicateValues = -1
	EnumWithDuplicateValuesR EnumWithDuplicateValues = 0
)

func (v EnumWithDuplicateValues) ToWire() wire.Value {
	return wire.NewValueI32(int32(v))
}
func (v *EnumWithDuplicateValues) FromWire(w wire.Value) error {
	*v = (EnumWithDuplicateValues)(w.GetI32())
	return nil
}

type EnumWithValues int32

const (
	EnumWithValuesX EnumWithValues = 123
	EnumWithValuesY EnumWithValues = 456
	EnumWithValuesZ EnumWithValues = 789
)

func (v EnumWithValues) ToWire() wire.Value {
	return wire.NewValueI32(int32(v))
}
func (v *EnumWithValues) FromWire(w wire.Value) error {
	*v = (EnumWithValues)(w.GetI32())
	return nil
}
func _Timestamp_Read(w wire.Value) (Timestamp, error) {
	var x Timestamp
	err := x.FromWire(w)
	return x, err
}
func _UUID_Read(w wire.Value) (*UUID, error) {
	var x UUID
	err := x.FromWire(w)
	return &x, err
}

type Event struct {
	Time *Timestamp
	UUID *UUID
}

func (v *Event) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	if v.Time != nil {
		fs[i] = wire.Field{ID: 2, Value: v.Time.ToWire()}
		i++
	}
	fs[i] = wire.Field{ID: 1, Value: v.UUID.ToWire()}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Event) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 2:
			if f.Value.Type() == wire.TI64 {
				var x Timestamp
				x, err = _Timestamp_Read(f.Value)
				v.Time = &x
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TStruct {
				v.UUID, err = _UUID_Read(f.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Event) String() string {
	var fs [2]string
	i := 0
	if v.Time != nil {
		fs[i] = fmt.Sprintf("Time: %v", *(v.Time))
		i++
	}
	fs[i] = fmt.Sprintf("UUID: %v", v.UUID)
	i++
	return fmt.Sprintf("Event{%v}", strings.Join(fs[:i], ", "))
}

type _List_Event_ValueList []*Event

func (v _List_Event_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_Event_ValueList) Close() {
}
func _Event_Read(w wire.Value) (*Event, error) {
	var v Event
	err := v.FromWire(w)
	return &v, err
}
func _List_Event_Read(l wire.List) ([]*Event, error) {
	if l.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]*Event, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := _Event_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}

type EventGroup []*Event

func (v EventGroup) ToWire() wire.Value {
	x := ([]*Event)(v)
	return wire.NewValueList(wire.List{ValueType: wire.TStruct, Size: len(x), Items: _List_Event_ValueList(x)})
}
func (v *EventGroup) FromWire(w wire.Value) error {
	x, err := _List_Event_Read(w.GetList())
	*v = (EventGroup)(x)
	return err
}
func _Size_Read(w wire.Value) (*Size, error) {
	var v Size
	err := v.FromWire(w)
	return &v, err
}

type Frame struct {
	Size    *Size
	TopLeft *Point
}

func (v *Frame) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 2, Value: v.Size.ToWire()}
	i++
	fs[i] = wire.Field{ID: 1, Value: v.TopLeft.ToWire()}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Frame) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 2:
			if f.Value.Type() == wire.TStruct {
				v.Size, err = _Size_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TStruct {
				v.TopLeft, err = _Point_Read(f.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Frame) String() string {
	var fs [2]string
	i := 0
	fs[i] = fmt.Sprintf("Size: %v", v.Size)
	i++
	fs[i] = fmt.Sprintf("TopLeft: %v", v.TopLeft)
	i++
	return fmt.Sprintf("Frame{%v}", strings.Join(fs[:i], ", "))
}

type _List_Edge_ValueList []*Edge

func (v _List_Edge_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(x.ToWire())
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_Edge_ValueList) Close() {
}
func _Edge_Read(w wire.Value) (*Edge, error) {
	var v Edge
	err := v.FromWire(w)
	return &v, err
}
func _List_Edge_Read(l wire.List) ([]*Edge, error) {
	if l.ValueType != wire.TStruct {
		return nil, nil
	}
	o := make([]*Edge, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := _Edge_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}

type Graph struct{ Edges []*Edge }

func (v *Graph) ToWire() wire.Value {
	var fs [1]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueList(wire.List{ValueType: wire.TStruct, Size: len(v.Edges), Items: _List_Edge_ValueList(v.Edges)})}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Graph) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TList {
				v.Edges, err = _List_Edge_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Graph) String() string {
	var fs [1]string
	i := 0
	fs[i] = fmt.Sprintf("Edges: %v", v.Edges)
	i++
	return fmt.Sprintf("Graph{%v}", strings.Join(fs[:i], ", "))
}

type Pdf []byte

func (v Pdf) ToWire() wire.Value {
	x := ([]byte)(v)
	return wire.NewValueBinary(x)
}
func (v *Pdf) FromWire(w wire.Value) error {
	x, err := w.GetBinary(), error(nil)
	*v = (Pdf)(x)
	return err
}

type Point struct {
	X float64
	Y float64
}

func (v *Point) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueDouble(v.X)}
	i++
	fs[i] = wire.Field{ID: 2, Value: wire.NewValueDouble(v.Y)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Point) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TDouble {
				v.X, err = f.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TDouble {
				v.Y, err = f.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Point) String() string {
	var fs [2]string
	i := 0
	fs[i] = fmt.Sprintf("X: %v", v.X)
	i++
	fs[i] = fmt.Sprintf("Y: %v", v.Y)
	i++
	return fmt.Sprintf("Point{%v}", strings.Join(fs[:i], ", "))
}

type _List_Binary_ValueList [][]byte

func (v _List_Binary_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(wire.NewValueBinary(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_Binary_ValueList) Close() {
}

type _List_I64_ValueList []int64

func (v _List_I64_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(wire.NewValueI64(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_I64_ValueList) Close() {
}

type _Map_I32_String_MapItemList map[int32]string

func (m _Map_I32_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueI32(k), Value: wire.NewValueString(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_I32_String_MapItemList) Close() {
}

type _Map_String_Bool_MapItemList map[string]bool

func (m _Map_String_Bool_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueString(k), Value: wire.NewValueBool(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_String_Bool_MapItemList) Close() {
}

type _Set_Byte_ValueList map[int8]struct{}

func (v _Set_Byte_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(wire.NewValueI8(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_Byte_ValueList) Close() {
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(wire.NewValueString(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_String_ValueList) Close() {
}
func _List_Binary_Read(l wire.List) ([][]byte, error) {
	if l.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make([][]byte, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetBinary(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _List_I64_Read(l wire.List) ([]int64, error) {
	if l.ValueType != wire.TI64 {
		return nil, nil
	}
	o := make([]int64, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetI64(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _Map_I32_String_Read(m wire.Map) (map[int32]string, error) {
	if m.KeyType != wire.TI32 {
		return nil, nil
	}
	if m.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make(map[int32]string, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _Map_String_Bool_Read(m wire.Map) (map[string]bool, error) {
	if m.KeyType != wire.TBinary {
		return nil, nil
	}
	if m.ValueType != wire.TBool {
		return nil, nil
	}
	o := make(map[string]bool, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetBool(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _Set_Byte_Read(s wire.Set) (map[int8]struct{}, error) {
	if s.ValueType != wire.TI8 {
		return nil, nil
	}
	o := make(map[int8]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetI8(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}
func _Set_String_Read(s wire.Set) (map[string]struct{}, error) {
	if s.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}

type PrimitiveContainers struct {
	ListOfBinary      [][]byte
	ListOfInts        []int64
	MapOfIntToString  map[int32]string
	MapOfStringToBool map[string]bool
	SetOfBytes        map[int8]struct{}
	SetOfStrings      map[string]struct{}
}

func (v *PrimitiveContainers) ToWire() wire.Value {
	var fs [6]wire.Field
	i := 0
	if v.ListOfBinary != nil {
		fs[i] = wire.Field{ID: 1, Value: wire.NewValueList(wire.List{ValueType: wire.TBinary, Size: len(v.ListOfBinary), Items: _List_Binary_ValueList(v.ListOfBinary)})}
		i++
	}
	if v.ListOfInts != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueList(wire.List{ValueType: wire.TI64, Size: len(v.ListOfInts), Items: _List_I64_ValueList(v.ListOfInts)})}
		i++
	}
	if v.MapOfIntToString != nil {
		fs[i] = wire.Field{ID: 5, Value: wire.NewValueMap(wire.Map{KeyType: wire.TI32, ValueType: wire.TBinary, Size: len(v.MapOfIntToString), Items: _Map_I32_String_MapItemList(v.MapOfIntToString)})}
		i++
	}
	if v.MapOfStringToBool != nil {
		fs[i] = wire.Field{ID: 6, Value: wire.NewValueMap(wire.Map{KeyType: wire.TBinary, ValueType: wire.TBool, Size: len(v.MapOfStringToBool), Items: _Map_String_Bool_MapItemList(v.MapOfStringToBool)})}
		i++
	}
	if v.SetOfBytes != nil {
		fs[i] = wire.Field{ID: 4, Value: wire.NewValueSet(wire.Set{ValueType: wire.TI8, Size: len(v.SetOfBytes), Items: _Set_Byte_ValueList(v.SetOfBytes)})}
		i++
	}
	if v.SetOfStrings != nil {
		fs[i] = wire.Field{ID: 3, Value: wire.NewValueSet(wire.Set{ValueType: wire.TBinary, Size: len(v.SetOfStrings), Items: _Set_String_ValueList(v.SetOfStrings)})}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *PrimitiveContainers) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TList {
				v.ListOfBinary, err = _List_Binary_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TList {
				v.ListOfInts, err = _List_I64_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 5:
			if f.Value.Type() == wire.TMap {
				v.MapOfIntToString, err = _Map_I32_String_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 6:
			if f.Value.Type() == wire.TMap {
				v.MapOfStringToBool, err = _Map_String_Bool_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 4:
			if f.Value.Type() == wire.TSet {
				v.SetOfBytes, err = _Set_Byte_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TSet {
				v.SetOfStrings, err = _Set_String_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *PrimitiveContainers) String() string {
	var fs [6]string
	i := 0
	if v.ListOfBinary != nil {
		fs[i] = fmt.Sprintf("ListOfBinary: %v", v.ListOfBinary)
		i++
	}
	if v.ListOfInts != nil {
		fs[i] = fmt.Sprintf("ListOfInts: %v", v.ListOfInts)
		i++
	}
	if v.MapOfIntToString != nil {
		fs[i] = fmt.Sprintf("MapOfIntToString: %v", v.MapOfIntToString)
		i++
	}
	if v.MapOfStringToBool != nil {
		fs[i] = fmt.Sprintf("MapOfStringToBool: %v", v.MapOfStringToBool)
		i++
	}
	if v.SetOfBytes != nil {
		fs[i] = fmt.Sprintf("SetOfBytes: %v", v.SetOfBytes)
		i++
	}
	if v.SetOfStrings != nil {
		fs[i] = fmt.Sprintf("SetOfStrings: %v", v.SetOfStrings)
		i++
	}
	return fmt.Sprintf("PrimitiveContainers{%v}", strings.Join(fs[:i], ", "))
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(wire.NewValueString(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_String_ValueList) Close() {
}

type _Map_I64_Double_MapItemList map[int64]float64

func (m _Map_I64_Double_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueI64(k), Value: wire.NewValueDouble(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_I64_Double_MapItemList) Close() {
}

type _Set_I32_ValueList map[int32]struct{}

func (v _Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(wire.NewValueI32(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_I32_ValueList) Close() {
}
func _List_String_Read(l wire.List) ([]string, error) {
	if l.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make([]string, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _Map_I64_Double_Read(m wire.Map) (map[int64]float64, error) {
	if m.KeyType != wire.TI64 {
		return nil, nil
	}
	if m.ValueType != wire.TDouble {
		return nil, nil
	}
	o := make(map[int64]float64, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI64(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetDouble(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _Set_I32_Read(s wire.Set) (map[int32]struct{}, error) {
	if s.ValueType != wire.TI32 {
		return nil, nil
	}
	o := make(map[int32]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}

type PrimitiveContainersRequired struct {
	ListOfStrings      []string
	MapOfIntsToDoubles map[int64]float64
	SetOfInts          map[int32]struct{}
}

func (v *PrimitiveContainersRequired) ToWire() wire.Value {
	var fs [3]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueList(wire.List{ValueType: wire.TBinary, Size: len(v.ListOfStrings), Items: _List_String_ValueList(v.ListOfStrings)})}
	i++
	fs[i] = wire.Field{ID: 3, Value: wire.NewValueMap(wire.Map{KeyType: wire.TI64, ValueType: wire.TDouble, Size: len(v.MapOfIntsToDoubles), Items: _Map_I64_Double_MapItemList(v.MapOfIntsToDoubles)})}
	i++
	fs[i] = wire.Field{ID: 2, Value: wire.NewValueSet(wire.Set{ValueType: wire.TI32, Size: len(v.SetOfInts), Items: _Set_I32_ValueList(v.SetOfInts)})}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *PrimitiveContainersRequired) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TList {
				v.ListOfStrings, err = _List_String_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TMap {
				v.MapOfIntsToDoubles, err = _Map_I64_Double_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TSet {
				v.SetOfInts, err = _Set_I32_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *PrimitiveContainersRequired) String() string {
	var fs [3]string
	i := 0
	fs[i] = fmt.Sprintf("ListOfStrings: %v", v.ListOfStrings)
	i++
	fs[i] = fmt.Sprintf("MapOfIntsToDoubles: %v", v.MapOfIntsToDoubles)
	i++
	fs[i] = fmt.Sprintf("SetOfInts: %v", v.SetOfInts)
	i++
	return fmt.Sprintf("PrimitiveContainersRequired{%v}", strings.Join(fs[:i], ", "))
}

type PrimitiveOptionalStruct struct {
	BinaryField []byte
	BoolField   *bool
	ByteField   *int8
	DoubleField *float64
	Int16Field  *int16
	Int32Field  *int32
	Int64Field  *int64
	StringField *string
}

func (v *PrimitiveOptionalStruct) ToWire() wire.Value {
	var fs [8]wire.Field
	i := 0
	if v.BinaryField != nil {
		fs[i] = wire.Field{ID: 8, Value: wire.NewValueBinary(v.BinaryField)}
		i++
	}
	if v.BoolField != nil {
		fs[i] = wire.Field{ID: 1, Value: wire.NewValueBool(*(v.BoolField))}
		i++
	}
	if v.ByteField != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueI8(*(v.ByteField))}
		i++
	}
	if v.DoubleField != nil {
		fs[i] = wire.Field{ID: 6, Value: wire.NewValueDouble(*(v.DoubleField))}
		i++
	}
	if v.Int16Field != nil {
		fs[i] = wire.Field{ID: 3, Value: wire.NewValueI16(*(v.Int16Field))}
		i++
	}
	if v.Int32Field != nil {
		fs[i] = wire.Field{ID: 4, Value: wire.NewValueI32(*(v.Int32Field))}
		i++
	}
	if v.Int64Field != nil {
		fs[i] = wire.Field{ID: 5, Value: wire.NewValueI64(*(v.Int64Field))}
		i++
	}
	if v.StringField != nil {
		fs[i] = wire.Field{ID: 7, Value: wire.NewValueString(*(v.StringField))}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *PrimitiveOptionalStruct) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 8:
			if f.Value.Type() == wire.TBinary {
				v.BinaryField, err = f.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TBool {
				var x bool
				x, err = f.Value.GetBool(), error(nil)
				v.BoolField = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TI8 {
				var x int8
				x, err = f.Value.GetI8(), error(nil)
				v.ByteField = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if f.Value.Type() == wire.TDouble {
				var x float64
				x, err = f.Value.GetDouble(), error(nil)
				v.DoubleField = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TI16 {
				var x int16
				x, err = f.Value.GetI16(), error(nil)
				v.Int16Field = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if f.Value.Type() == wire.TI32 {
				var x int32
				x, err = f.Value.GetI32(), error(nil)
				v.Int32Field = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if f.Value.Type() == wire.TI64 {
				var x int64
				x, err = f.Value.GetI64(), error(nil)
				v.Int64Field = &x
				if err != nil {
					return err
				}
			}
		case 7:
			if f.Value.Type() == wire.TBinary {
				var x string
				x, err = f.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *PrimitiveOptionalStruct) String() string {
	var fs [8]string
	i := 0
	if v.BinaryField != nil {
		fs[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}
	if v.BoolField != nil {
		fs[i] = fmt.Sprintf("BoolField: %v", *(v.BoolField))
		i++
	}
	if v.ByteField != nil {
		fs[i] = fmt.Sprintf("ByteField: %v", *(v.ByteField))
		i++
	}
	if v.DoubleField != nil {
		fs[i] = fmt.Sprintf("DoubleField: %v", *(v.DoubleField))
		i++
	}
	if v.Int16Field != nil {
		fs[i] = fmt.Sprintf("Int16Field: %v", *(v.Int16Field))
		i++
	}
	if v.Int32Field != nil {
		fs[i] = fmt.Sprintf("Int32Field: %v", *(v.Int32Field))
		i++
	}
	if v.Int64Field != nil {
		fs[i] = fmt.Sprintf("Int64Field: %v", *(v.Int64Field))
		i++
	}
	if v.StringField != nil {
		fs[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	return fmt.Sprintf("PrimitiveOptionalStruct{%v}", strings.Join(fs[:i], ", "))
}

type PrimitiveRequiredStruct struct {
	BinaryField []byte
	BoolField   bool
	ByteField   int8
	DoubleField float64
	Int16Field  int16
	Int32Field  int32
	Int64Field  int64
	StringField string
}

func (v *PrimitiveRequiredStruct) ToWire() wire.Value {
	var fs [8]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 8, Value: wire.NewValueBinary(v.BinaryField)}
	i++
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueBool(v.BoolField)}
	i++
	fs[i] = wire.Field{ID: 2, Value: wire.NewValueI8(v.ByteField)}
	i++
	fs[i] = wire.Field{ID: 6, Value: wire.NewValueDouble(v.DoubleField)}
	i++
	fs[i] = wire.Field{ID: 3, Value: wire.NewValueI16(v.Int16Field)}
	i++
	fs[i] = wire.Field{ID: 4, Value: wire.NewValueI32(v.Int32Field)}
	i++
	fs[i] = wire.Field{ID: 5, Value: wire.NewValueI64(v.Int64Field)}
	i++
	fs[i] = wire.Field{ID: 7, Value: wire.NewValueString(v.StringField)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *PrimitiveRequiredStruct) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 8:
			if f.Value.Type() == wire.TBinary {
				v.BinaryField, err = f.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TBool {
				v.BoolField, err = f.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TI8 {
				v.ByteField, err = f.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
			}
		case 6:
			if f.Value.Type() == wire.TDouble {
				v.DoubleField, err = f.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TI16 {
				v.Int16Field, err = f.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
			}
		case 4:
			if f.Value.Type() == wire.TI32 {
				v.Int32Field, err = f.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
			}
		case 5:
			if f.Value.Type() == wire.TI64 {
				v.Int64Field, err = f.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
			}
		case 7:
			if f.Value.Type() == wire.TBinary {
				v.StringField, err = f.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *PrimitiveRequiredStruct) String() string {
	var fs [8]string
	i := 0
	fs[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++
	fs[i] = fmt.Sprintf("BoolField: %v", v.BoolField)
	i++
	fs[i] = fmt.Sprintf("ByteField: %v", v.ByteField)
	i++
	fs[i] = fmt.Sprintf("DoubleField: %v", v.DoubleField)
	i++
	fs[i] = fmt.Sprintf("Int16Field: %v", v.Int16Field)
	i++
	fs[i] = fmt.Sprintf("Int32Field: %v", v.Int32Field)
	i++
	fs[i] = fmt.Sprintf("Int64Field: %v", v.Int64Field)
	i++
	fs[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	return fmt.Sprintf("PrimitiveRequiredStruct{%v}", strings.Join(fs[:i], ", "))
}

type Size struct {
	Height float64
	Width  float64
}

func (v *Size) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 2, Value: wire.NewValueDouble(v.Height)}
	i++
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueDouble(v.Width)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Size) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 2:
			if f.Value.Type() == wire.TDouble {
				v.Height, err = f.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TDouble {
				v.Width, err = f.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Size) String() string {
	var fs [2]string
	i := 0
	fs[i] = fmt.Sprintf("Height: %v", v.Height)
	i++
	fs[i] = fmt.Sprintf("Width: %v", v.Width)
	i++
	return fmt.Sprintf("Size{%v}", strings.Join(fs[:i], ", "))
}

type State string

func (v State) ToWire() wire.Value {
	x := (string)(v)
	return wire.NewValueString(x)
}
func (v *State) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (State)(x)
	return err
}

type Timestamp int64

func (v Timestamp) ToWire() wire.Value {
	x := (int64)(v)
	return wire.NewValueI64(x)
}
func (v *Timestamp) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Timestamp)(x)
	return err
}
func _EventGroup_Read(w wire.Value) (EventGroup, error) {
	var x EventGroup
	err := x.FromWire(w)
	return x, err
}
func _State_Read(w wire.Value) (State, error) {
	var x State
	err := x.FromWire(w)
	return x, err
}

type Transition struct {
	Events EventGroup
	From   State
	To     State
}

func (v *Transition) ToWire() wire.Value {
	var fs [3]wire.Field
	i := 0
	if v.Events != nil {
		fs[i] = wire.Field{ID: 3, Value: v.Events.ToWire()}
		i++
	}
	fs[i] = wire.Field{ID: 1, Value: v.From.ToWire()}
	i++
	fs[i] = wire.Field{ID: 2, Value: v.To.ToWire()}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *Transition) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 3:
			if f.Value.Type() == wire.TList {
				v.Events, err = _EventGroup_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TBinary {
				v.From, err = _State_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TBinary {
				v.To, err = _State_Read(f.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *Transition) String() string {
	var fs [3]string
	i := 0
	if v.Events != nil {
		fs[i] = fmt.Sprintf("Events: %v", v.Events)
		i++
	}
	fs[i] = fmt.Sprintf("From: %v", v.From)
	i++
	fs[i] = fmt.Sprintf("To: %v", v.To)
	i++
	return fmt.Sprintf("Transition{%v}", strings.Join(fs[:i], ", "))
}

type UUID I128

func (v *UUID) ToWire() wire.Value {
	x := (*I128)(v)
	return x.ToWire()
}
func (v *UUID) FromWire(w wire.Value) error {
	return (*I128)(v).FromWire(w)
}
func _ContactInfo_Read(w wire.Value) (*ContactInfo, error) {
	var v ContactInfo
	err := v.FromWire(w)
	return &v, err
}

type User struct {
	Contact *ContactInfo
	Name    string
}

func (v *User) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	if v.Contact != nil {
		fs[i] = wire.Field{ID: 2, Value: v.Contact.ToWire()}
		i++
	}
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueString(v.Name)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *User) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 2:
			if f.Value.Type() == wire.TStruct {
				v.Contact, err = _ContactInfo_Read(f.Value)
				if err != nil {
					return err
				}
			}
		case 1:
			if f.Value.Type() == wire.TBinary {
				v.Name, err = f.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *User) String() string {
	var fs [2]string
	i := 0
	if v.Contact != nil {
		fs[i] = fmt.Sprintf("Contact: %v", v.Contact)
		i++
	}
	fs[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	return fmt.Sprintf("User{%v}", strings.Join(fs[:i], ", "))
}

type I128 struct {
	High int64
	Low  int64
}

func (v *I128) ToWire() wire.Value {
	var fs [2]wire.Field
	i := 0
	fs[i] = wire.Field{ID: 1, Value: wire.NewValueI64(v.High)}
	i++
	fs[i] = wire.Field{ID: 2, Value: wire.NewValueI64(v.Low)}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *I128) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TI64 {
				v.High, err = f.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TI64 {
				v.Low, err = f.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (v *I128) String() string {
	var fs [2]string
	i := 0
	fs[i] = fmt.Sprintf("High: %v", v.High)
	i++
	fs[i] = fmt.Sprintf("Low: %v", v.Low)
	i++
	return fmt.Sprintf("I128{%v}", strings.Join(fs[:i], ", "))
}
