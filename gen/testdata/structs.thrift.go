// Code generated by thriftrw

package testdata

import "github.com/thriftrw/thriftrw-go/wire"

type _List_Binary_ValueList [][]byte

func (v _List_Binary_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(wire.NewValueBinary(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_Binary_ValueList) Close() {
}

type _List_I64_ValueList []int64

func (v _List_I64_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		err := f(wire.NewValueI64(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _List_I64_ValueList) Close() {
}

type _Map_I32_String_MapItemList map[int32]string

func (m _Map_I32_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueI32(k), Value: wire.NewValueString(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_I32_String_MapItemList) Close() {
}

type _Map_String_Bool_MapItemList map[string]bool

func (m _Map_String_Bool_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		err := f(wire.MapItem{Key: wire.NewValueString(k), Value: wire.NewValueBool(v)})
		if err != nil {
			return err
		}
	}
	return nil
}
func (m _Map_String_Bool_MapItemList) Close() {
}

type _Set_Byte_ValueList map[int8]struct{}

func (v _Set_Byte_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(wire.NewValueI8(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_Byte_ValueList) Close() {
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		err := f(wire.NewValueString(x))
		if err != nil {
			return err
		}
	}
	return nil
}
func (v _Set_String_ValueList) Close() {
}
func _List_Binary_Read(l wire.List) ([][]byte, error) {
	if l.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make([][]byte, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		var err error
		i, err := x.GetBinary(), nil
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _List_I64_Read(l wire.List) ([]int64, error) {
	if l.ValueType != wire.TI64 {
		return nil, nil
	}
	o := make([]int64, 0, l.Size)
	err := l.Items.ForEach(func(x wire.Value) error {
		var err error
		i, err := x.GetI64(), nil
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Items.Close()
	return o, err
}
func _Map_I32_String_Read(m wire.Map) (map[int32]string, error) {
	if m.KeyType != wire.TI32 {
		return nil, nil
	}
	if m.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make(map[int32]string, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		var err error
		k, err := x.Key.GetI32(), nil
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), nil
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _Map_String_Bool_Read(m wire.Map) (map[string]bool, error) {
	if m.KeyType != wire.TBinary {
		return nil, nil
	}
	if m.ValueType != wire.TBool {
		return nil, nil
	}
	o := make(map[string]bool, m.Size)
	err := m.Items.ForEach(func(x wire.MapItem) error {
		var err error
		k, err := x.Key.GetString(), nil
		if err != nil {
			return err
		}
		v, err := x.Value.GetBool(), nil
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Items.Close()
	return o, err
}
func _Set_Byte_Read(s wire.Set) (map[int8]struct{}, error) {
	if s.ValueType != wire.TI8 {
		return nil, nil
	}
	o := make(map[int8]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		var err error
		i, err := x.GetI8(), nil
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}
func _Set_String_Read(s wire.Set) (map[string]struct{}, error) {
	if s.ValueType != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]struct{}, s.Size)
	err := s.Items.ForEach(func(x wire.Value) error {
		var err error
		i, err := x.GetString(), nil
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Items.Close()
	return o, err
}

type PrimitiveContainers struct {
	ListOfBinary      [][]byte
	ListOfInts        []int64
	MapOfIntToString  map[int32]string
	MapOfStringToBool map[string]bool
	SetOfBytes        map[int8]struct{}
	SetOfStrings      map[string]struct{}
}

func (v *PrimitiveContainers) ToWire() wire.Value {
	var fs [6]wire.Field
	i := 0
	if v.ListOfBinary != nil {
		fs[i] = wire.Field{ID: 1, Value: wire.NewValueList(wire.List{ValueType: wire.TBinary, Size: len(v.ListOfBinary), Items: _List_Binary_ValueList(v.ListOfBinary)})}
		i++
	}
	if v.ListOfInts != nil {
		fs[i] = wire.Field{ID: 2, Value: wire.NewValueList(wire.List{ValueType: wire.TI64, Size: len(v.ListOfInts), Items: _List_I64_ValueList(v.ListOfInts)})}
		i++
	}
	if v.MapOfIntToString != nil {
		fs[i] = wire.Field{ID: 5, Value: wire.NewValueMap(wire.Map{KeyType: wire.TI32, ValueType: wire.TBinary, Size: len(v.MapOfIntToString), Items: _Map_I32_String_MapItemList(v.MapOfIntToString)})}
		i++
	}
	if v.MapOfStringToBool != nil {
		fs[i] = wire.Field{ID: 6, Value: wire.NewValueMap(wire.Map{KeyType: wire.TBinary, ValueType: wire.TBool, Size: len(v.MapOfStringToBool), Items: _Map_String_Bool_MapItemList(v.MapOfStringToBool)})}
		i++
	}
	if v.SetOfBytes != nil {
		fs[i] = wire.Field{ID: 4, Value: wire.NewValueSet(wire.Set{ValueType: wire.TI8, Size: len(v.SetOfBytes), Items: _Set_Byte_ValueList(v.SetOfBytes)})}
		i++
	}
	if v.SetOfStrings != nil {
		fs[i] = wire.Field{ID: 3, Value: wire.NewValueSet(wire.Set{ValueType: wire.TBinary, Size: len(v.SetOfStrings), Items: _Set_String_ValueList(v.SetOfStrings)})}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fs[:i]})
}
func (v *PrimitiveContainers) FromWire(w wire.Value) error {
	var err error
	for _, f := range w.GetStruct().Fields {
		switch f.ID {
		case 1:
			if f.Value.Type() == wire.TList {
				v.ListOfBinary, err = _List_Binary_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if f.Value.Type() == wire.TList {
				v.ListOfInts, err = _List_I64_Read(f.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 5:
			if f.Value.Type() == wire.TMap {
				v.MapOfIntToString, err = _Map_I32_String_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 6:
			if f.Value.Type() == wire.TMap {
				v.MapOfStringToBool, err = _Map_String_Bool_Read(f.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 4:
			if f.Value.Type() == wire.TSet {
				v.SetOfBytes, err = _Set_Byte_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 3:
			if f.Value.Type() == wire.TSet {
				v.SetOfStrings, err = _Set_String_Read(f.Value.GetSet())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func _PrimitiveContainers_Read(w wire.Value) (*PrimitiveContainers, error) {
	var v PrimitiveContainers
	err := v.FromWire(w)
	return &v, err
}
